const APIInterface = require("libresignage/api/APIInterface");
const APIEndpoints = require("libresignage/api/APIEndpoints");
const sinon = require("sinon")
const Assert = require("assert")
const Ajv = require("ajv")

const API_REQUEST = 0;
const API_RESPONSE = 1;

const REQUEST_SCHEMA_PREFIX = "file://api/schemas/request/";
const RESPONSE_SCHEMA_PREFIX = "file://api/schemas/response/"

const ENDPOINT_SCHEMA_MAP = {
	QUEUE_GET: `queue/queue_get.schema.json`,
	QUEUE_CREATE: `queue/queue_create.schema.json`,
	QUEUE_REMOVE: `queue/queue_remove.schema.json`,
	QUEUE_LIST: `queue/queue_list.schema.json`,
	SLIDE_GET: `slide/slide_get.schema.json`,
}

class APIInterfaceStub extends APIInterface {
	constructor(host) {
		super(host);

		this.ajv = new Ajv({
			useDefaults: true,
			loadSchema: async (uri) => APIInterfaceStub.load_schema(uri)
		});

		// Stub APIInterface.call() to return preprogrammed data.
		let call_stub = sinon.stub(this, "call");
		let call_fake = {}

		call_fake["QUEUE_GET"] = async (endpoint, data) => ({
			"queue": {
				"owner": "admin",
				"slide_ids": ["0"]
			}
		});

		call_fake["QUEUE_CREATE"] = async (endpoint, data) => ({});

		call_fake["QUEUE_REMOVE"] = async (endpoint, data) => ({});

		call_fake["QUEUE_LIST"] = async (endpoint, data) => ({
			"queues": ["default"],
		});

		call_fake["SLIDE_GET"] = async (endpoint, data) => ({
			"slide": {
				"id": "0",
				"name": "stubbed",
				"duration": 5,
				"markup": "",
				"owner": "admin",
				"enabled": true,
				"sched": false,
				"sched_t_s": 0,
				"sched_t_e": 0,
				"animation": 0,
				"collaborators": [],
				"lock": null,
				"assets": [],
				"ref_count": 1
			}
		});

		/*
		 * Make APIInterface.call() return the correct
		 * data for the correct endpoint.
		 */
		for (let endpoint_name in call_fake) {
			call_stub.withArgs(
				APIEndpoints[endpoint_name]
			).callsFake(async (endpoint, data) => {
				// Validate request schema.
				await this.validate_data_against_schema(
					endpoint,
					API_REQUEST,
					data
				);

				let ret = await call_fake[endpoint_name](endpoint, data);

				// Validate response schema.
				await this.validate_data_against_schema(
					endpoint,
					API_RESPONSE,
					ret
				);

				return ret;
			})
		}
	}

	/**
	 * Load a schema file from the file system.
	 *
	 * @param {string} uri The path to the schema file preficed by "file://".
	 *                     Paths are relative to src/ in the LibreSignage repo.
	 */
	static load_schema(uri) {
		return require(uri.replace(/^file:\/\//, "src/"));
	}

	/**
	 * Validate API request data against a JSON schema.
	 *
	 * @param {object} data The request data object.
	 * @param {string} schema_path The JSON schema path.
	 *
	 * @throws {AssertionError} If the request data doesn't match the schema.
	 */
	async validate_data_against_schema(endpoint, type, data) {
		// Find the schema path based on the endpoint object.
		let schema_path = null;
		for (let e in APIEndpoints) {
			if (APIEndpoints[e].uri === endpoint.uri) {
				// Select the correct schema based on whether this is a
				// request or a response.
				if (type == API_REQUEST) {
					schema_path = REQUEST_SCHEMA_PREFIX;
				} else if (type == API_RESPONSE) {
					schema_path = RESPONSE_SCHEMA_PREFIX;
				} else {
					throw new Error("Unknown API data type to validate.");
				}
				schema_path += ENDPOINT_SCHEMA_MAP[e];
			}
		}

		// Load the schema from file.
		if (!schema_path) { throw new Error("No such endpoint."); }
		let schema = APIInterfaceStub.load_schema(schema_path);

		// Validate data.
		let validate = await this.ajv.compileAsync(schema);
		validate(data);

		// Throw on validation error.
		if (validate.errors != null) {
			throw new Ajv.ValidationError(validate.errors);
		}
	}
}

module.exports = APIInterfaceStub;
